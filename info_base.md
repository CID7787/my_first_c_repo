[HTML info base](https://farrukh-programming-lessons.glitch.me/info_base.html)

/--(forward)slash

`\`--backslash
```
- When we write a program in C,
we have to use Format Specifiers to define the variable type in input and output
and Escape Characters to format the output.
```
Translators:

- Compilers (C/C++)
  - Transpilers ( PHP -> C)
- Interpreters (JS)
  - Just-in-time compilers (JIT)
  - Bytecode interpreters

---

Категоризация файлов:

- исполняемые (в которых находятся инструкции для исполнения) и файлы с данными (картинки, видео, аудио, текст, т.д.)
- бинарные (двоичные) и текстовые

---

Расширения:

- `.exe` - сокращение от `executable`, что переводитTranslators:

- Compilers (C/C++)
  - Transpilers ( PHP -> C)
- Interpreters (JS)
  - Just-in-time compilers (JIT)
  - Bytecode interpreters

---



Расширения:

- `.exe` - сокращение от `executable`, что переводитell file
- `.c`
- `.txt`
- `.js`
- `.html` - язык разметки [HTML](<[HTML](https://www.w3schools.com/tags/default.asp)>) (**H**yper-**T**ext **M**arkup **L**anguage)
- `.md` - язык разметки [Markdown](https://www.markdownguide.org/basic-syntax/)
- без расширения (Unix)

---

Paradigms:

  - imperative
  - procedural
  - structural: Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making specific disciplined use of the structured control flow constructs of selection and repetition, block structures, and subroutines.
  - object-oriented
  - declarative
  - functional

---

[List of C Keywords](https://en.cppreference.com/w/c/keyword)  
[C Operator precedence](https://en.cppreference.com/w/c/language/operator_precedence)  
[C Standards](https://iso-9899.info/wiki/The_Standard) \( [C99](https://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf) \)  
[Nullable pointer in c](https://stackoverflow.com/questions/77310920/what-is-nullable-pointer-in-c/77310990#77310990)\
// https://en.wikipedia.org/wiki/Instruction_set_architecture
// https://en.wikipedia.org/wiki/Tunnel_vision
// https://en.wikipedia.org/wiki/Von_Neumann_architecture
// https://en.wikipedia.org/wiki/Harvard_architecture
// https://killedbygoogle.com/
// https://www.programmingfonts.org/
// https://betterexplained.com
// https://www.mathsisfun.com/algebra/logarithms.html
// https://www.youtube.com/watch?v=IxXaizglscw
// https://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf
// https://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_toc.html#SEC_Contents

---

[De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws):

```
!!X = X
!(X && Y) == (!X) || (!Y)
!(X || Y) == (!X) && (!Y)
```


- string rendering
```
  char *s0 = "";

  (b) (b) (b) (b) (b) (b) (b) (b)
  [b] [b] [b] [b] [b] [b] [b] [b]


  char * s1 = "|.";
  [w] [b] [b] [b] [b] [b] [b] [b]
  [w] [w] [b] [b] [b] [b] [b] [b]


  char * s2 = "|.............";

  [w] [b] [b] [b] [b] [b] [b] [b]
  [w] [w] [w] [w] [w] [w] [w] [w]
```
- testing
```c
  unsigned int i = 100;
  while (i-- > 0) {
     // tested function:
    unsigned int result = addition(i, 10);
    if (result != (i+10)) { printf("\nERROR! %u + 10 != %u", i, result); }
  }


- optic fiber ?
- floating and variable constants?
- implementation?

 - Insert, или Inst, — клавиша на клавиатуре IBM PC-совместимых компьютеров, предназначенная для переключения из режима «вставки» (в этом режиме текстовый редактор вводит текст, начиная с точки вставки, и помещает его правее по странице) в режим «замены» (в этом режиме текст, который вводится с клавиатуры, будет заменять собой уже напечатанный до того текст).

 - Square brackets [ ]: The opening and closing brackets represent the single and multidimensional subscripts.
 - Simple brackets ( ): It is used in function declaration and function calling. For example, printf() is a pre-defined function.
 - Curly braces { }: It is used in the opening and closing of the code. It is used in the opening and closing of the loops.
 - Comma (,): It is used for separating for more than one statement and for example, separating function parameters in a function call, separating the variable when printing the value of more than one variable using a single printf statement.
 - Hash/pre-processor (#): It is used for pre-processor directive. It basically denotes that we are using the header file.
 - Asterisk (*): This symbol is used to represent pointers and also used as an operator for multiplication.
 - Tilde (~): It is used as a destructor to free memory.
 - Period (.): It is used to access a member of a structure or a union.
```

  
 


0  1  2  3  4  5  6 ...  (N)
|  |  |  |  |  |  |
0  1 -1  2 -2  3 -3 .... (Z)


(N)   (R)
0     1.00000000000000000000000
1     0.10000000000000000000000
2     0.01000000000000000000000
3     0.00100000000000000000000
4     0.0001000![alt text](image.png)0000000000000000
...

1.111111111111111111111111.....
2.000000000000000000000000.....
3.000000000000000000000000.....


- Исчислимые и неисчислимые множества (диагональный аргумент Кантора)
- Кардинальность
- Аналитическая и дискретная математика
- Аналоговый и цифоровой сигнал
- Аналоговый и цифровой компьютер
- Поле (физика)
- 4 фундаментальных взаимодействия
- элементарные и фундаментальные частицы
- носители
- бозоны и фермионы
- фотон, электрон, нейтрино, ...
- Фотоэлектрический эффект
- Частотный спектр (спектр)
- Палочки и колбочки
- R(ed)G(reen)B(lue)
- Аналогово-цифровой преобразователь
- API = Applied Programming Interface = ППИ = Прикладной Программный интерфейс
- WebAPI

1) напишем программу, которая будет "слушать" по определенному порту на определенном IP адресе (127.0.0.1) определенные комманды.
2) Принимать размер текста, сам текст программы на языке С.
3) Выполнит код локально у тебя на компьютере
4) Возвращать результат выполнения тому, кто прислал запрос.


### ANY RECURSION CAN BE TURNED INTO AN ITERATION!!!
```c
int factorial(int x) { // 6
  if (x > 1) { return multiplication(x, factorial(x-1)); }
  return 1;
}
int iterative_factorial(int x){
  int product = 1;
  while(x) { product = multiplication(product, predecrement(&x)); }
  return product;
}
```

### ABOUT UNIONS AND STRUCT STORING DATA
```
                                  ┌─────┬─────┐
struct { int a; float b }  gives  │  a  │  b  │
                                 └─────┴─────┘
                                    ▲     ▲
                                    │     │
                 memory location:  150   154
                                    │
                                    ▼
                                 ┌─────┐    
union { int a; float b }  gives  │  a  │ or ┌──────┐
                                 │  b  │    │  ab  │
                                 └─────┘    └──────┘
```
```
The Qualifiers are the keywords which are applied to the data types or type modifiers in C.
A qualifier applied to basic data types to alter or modify its sign or size.
There are three types of type qualifiers namely, Size Qualifiers (short, long) and Sign Qualifiers (signed,
unsigned) and the type qualifiers.
```


```
Statements are fragments of the C program that are executed in sequence. The body of any function is a compound statement, which, in turn is a sequence of statements and declarations:

int main(void)
{ // start of a compound statement
    int n = 1; // declaration (not a statement)
    n = n+1; // expression statement
    printf("n = %d\n", n); // expression statement
    return 0; // return statement
} // end of compound statement, end of function body



```
```
Memory leaks happens when you assign a value to a pointer, and then you lose the original value of the pointer.
   For example:
int main(){
char* a = "old text"; // allocate memory
a = "new text"; // after this assignment, "old text
is now a region in memory lost.
return 0;
}
The "old text" is still within a program memory, so OS cannot clear it. But inside a program, you 
have lost track of it.
```

```
KEY POINTS OF AMIRAKO'S LECTURE    
        ----------------------------------------------
       |                                             \/
  1) Basics -> algorithms & data structures <- numerical methods
                                            -> domain-specific
                                            -> architecture
  2) high-level abstractions -> algorithms & data structures -> return to basics
  
>> 1
 00000001|10|101


  magnitude (прямой код)
  1111  =  15
  0111  =  7
  0000  = 0 
  
  sign and magnitude (прямой код)
  1111  = -7
  0111  = 7
  0000 = +0
  1000 = -0
  
  increment(a)
  
  One's complement (обратный код)
  
  Two's complement (дополнительный код)
  1111 = -1
  1110 = -2
  1101 = -3
  1100 = -4
  1011 = -5
  1010 = -6
  1001 = -7
  1000 = -8
  0111 = 7
  ...
  0011 = 3
  0010 = 2
  0001 = 1
  0000 = 0
  
  offset binary (двоичный сдвиг)
```
 ```
  THROUGH WHICH PATHES WE CAN INFORM ABOUT MISTAKE

  1) Зарезервировать 1 значение как специальное значение
  2) Выделить память после числа, в которой будет метаинформация про число
  3) Выделить 1 бит внутри памяти числа
  4) Компилятор хранит информацию в типе данных
  5) Функции возвращают несколько значений
  

 ```



 ```
 You can define a data type keyword as an alias for any type, and then use the alias syntactically like a built-in type keyword such as int. You do this using typedef, so these aliases are also called typedef names.
  Example: 
   typedef int HELLO;
    HELLO a; // == int a;
  Alias "HELLO" here is the (same as) typedef int 's typedef name

There is a syntactic difference, however, between frobcount and int: A typedef name cannot be used with signed, unsigned, long or short. It has to specify the type all by itself. So you can’t write this:

unsigned frobcount f1;  /* Error! */

But you can write this:

typedef unsigned int unsigned_frobcount;

unsigned_frobcount f1;



  ASK ABOUT THIS AMIRAKO: Warning: Avoid defining typedef names that end in ‘_t’, because many of these have standard meanings.

You can redefine a typedef name to the exact same type as its first definition, but you cannot redefine a typedef name to a different type, even if the two types are compatible. For example, this is valid:

typedef int frobcount;
typedef int frotzcount;
typedef frotzcount frobcount;
typedef frobcount frotzcount;

because each typedef name is always defined with the same type (int), but this is not valid:

enum foo {f1, f2, f3};
typedef enum foo frobcount;
typedef int frobcount;

Even though the type enum foo is compatible with int, they are not the same type.


 ```

 ```
Initializing a variable means assigning some value to it for the very first time. 
We must override garbage value, just after variable declaration. 

 ```
 ```
   /*Memory leaks happens when you assign a value to a pointer, and then you lose the original value of the pointer.
   For example:
int main(){
char* a = "old text"; // allocate memory
a = "new text"; // after this assignment, "old text
is now a region in memory lost.
return 0;
}
The "old text" is still within a program memory, so OS cannot clear it. But inside a program, you 
have lost track of it.*/
 ```

```
Run-time is the fineal phase of a computer program's life cycle, in which the code is being executed on the computer's central processing unit(CPU) as machine code.
Compile-time describes the time interval during which a language's statements are converted into binary instructions for the processor to execute. 
```


```
At the top of every Linux file system directory structure '/' that is / (root) directory 
. - curent directory
.. - parent directory of the current directory
/ - root directory
~ - home directory
```

```
C struct
*After structure definition, we have to create variable of that structure to use it. It is similar to the any other type of variable declaration:

e.g.    struct structure_name var;

*We can also declare structure variables with structure definition.(tyypedef struct struct_name{.....}alias var1, var2; WHY NOT?)

e.g    struct structure_name {
        ...
       }var1, var2....;


*In the case where we have a pointer to the structure, we can also use the arrow operator to access the members.(works for unions too)(HOW IT WORKS?)

    structure_ptr -> member1
    structure_ptr -> member2
    
    (*structure_ptr).member1;
    structure_ptr->member1;

REASON: When a datatype is declared, no memory is allocated for it. Memory is allocated only when variables are created.

*By default, structure members are not automatically initialized to 0 or NULL. Uninitialized structure members will contain garbage values. However, when a structure variable is declared with an initializer, all members not explicitly initialized are zero-initialized.

*Initialization using Initializer List

    struct structure_name str = {value1, value2, value3 ....};

In this type of initialization, the values are assigned in sequential order as they are declared in the structure template.

*Initialization using Designated Initializer List

Designated Initialization allows structure members to be initialized in any order. This feature has been added in the C99 standard.

    struct structure_name str = { .member1 = value1, .member2 = value2, .member3 = value3 };
```

```
C union
An anonymous union in C is a union that does not have a name. Instead of accessing its members through a named union variable, you can directly access the members of the anonymous union. This is useful when you want to access the union members directly within a specific scope, without needing to declare a union variable.

Example:

#include <stdio.h>

struct Student {
    int rollNo;
        union {
        int marks;
    } performance;
};

int main() {
    struct Student abc;
    abc.rollNo = 21;
    printf("%d\n", abc.rollNo);
    abc.performance.marks = 91;
    printf("%d", abc.performance.marks);
    return 0;
}
```

```
How type-casting in C works:

The right-shift operator causes the bit pattern in shift-expression to be shifted to the right by the number of positions specified by additive-expression.
For unsigned numbers, the bit positions that have been vacated by the shift operation are zero-filled.
For signed numbers, the sign bit is used to fill the vacated bit positions.(it means all bit which values have been moved to right will be fill 1)
In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.

double d = 10.0;
*((long unsigned int *)&d); // preserves the bit representation
double d = 10.0;
(long unsigned int) d; // transforms the value into the closest match

```

```
IMPLICIT TYPE CONVERTION OR OPERAND PROMOTIONS:
The operands in arithmetic operations undergo type conversion automatically. These operand promotions are the same as the argument promotions except without converting float to double. In other words, the operand promotions convert

    char or short (whether signed or not) to int.
    an array to a pointer to its zeroth element, and 
```

```
GOOD SOURCE FOR REFERENCING TO DEFINITION OF CONCEPTS IN C(and good guide for begginers)

https://users.cs.jmu.edu/bernstdh/web/common/lectures/summary_c_scope-duration-linkage.php

```

``` compiler will count size of arr during compile time
unsigned int arr[] = {1, 2, 4, 8, 10, 15, 21, 23, 24, 27};
sizeof(arr);
```

``` C arrays, pointers and arrays decay

// pointer decay
// static array decays to a pointer

Array is a sequence of homogeneous elements in memory. Example: [00000000, 00000000, 00000000, 00000000] - is a sequence of chars

static array is a data type which has a pointer to the beginning of this memory + the size + some type information about the array
dynamic array is just a pointer to the beginning of this memory + type information about pointer type

When a pointer decay happens, we lose information about the size and type information about the array
```


```FUNCTION
f: N -> R  // function declaration
f(x) = sqrt(x) // function definition
```

```
UI:
  Terminal UI (TUI, Text UI, Console UI)
  Graphical UI (GUI)


man - is console(terminal) command that provides manual of other commands 
sample: man git
```

```
Commands are simply programs which are placed in a specific location visible from Shell.

In Linux, this directory is typically:
/usr/bin/
/bin/
/usr/local/bin/

In Windows, you need to add the path to a PATH variable
```

```
Programs are divided into 2 types: console programs(program that receives text argument and returns text result) and graphical programs(programs that receives something and return graphical result).
```

```
UI(User Interface):
  Terminal UI (TUI, Text UI, Console UI)
  Graphical UI (GUI)
```

```
SOME ENGLISH TIPS ABOUT TENSES:
I did go there - Я таки пошел туда (акцент на там, что ты действительно это сделал)
I went there - Я пошел туда (акцент на том, куда ты сходил)
I have gone there - Я сходил туда (акцент на том, что ты совершил действие)

I did go there yesterday - Я ТАКИ пошел туда вчера.
I went there yesterday - Я пошел туда ВЧЕРА.
I have gone there yesterday - Я СХОДИЛ туда вчера.
```

``` command line (console command) for creating files
echo "amirako" > compile.sh

all console commands work with the following principle: 
- they transform input into output(both input and output are text)
- when several commands put their output into the next commands input, this is known as [piping](https://www.geeksforgeeks.org/linux-unix/piping-in-unix-or-linux/)
- filename is just a text string 


when creating a file, what you are really doing is piping the text output of the command on the left into a filename on the right

| execute the next command independent of the previous command
&& execute the next command only if the previous command was successful
|| execute the next command only if the previous command returned an error
``` 

```
NAN:
Quiet NaNq
In general, quiet NaNs, or qNaNs, do not raise any additional exceptions, as they propagate through most operations. But the invalid-operation exception is signaled by some operations that do not return a floating-point value, such as format conversions or certain comparison operations. 
Signaling NaN

Signaling NaNs
sNaNs, are special forms of a NaN that, when consumed by most operations, should raise the invalid operation exception and then, if appropriate, be "quieted" into a qNaN that may then propagate. They were introduced in IEEE 754. There have been several ideas for how these might be used:

    Filling uninitialized memory with signaling NaNs would produce the invalid operation exception if the data is used before it is initialized
    Using an sNaN as a placeholder for a more complicated object, such as:
        A representation of a number that has underflowed
        A representation of a number that has overflowed
        Number in a higher precision format
        A complex number
